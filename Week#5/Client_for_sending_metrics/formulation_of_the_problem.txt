Клієнт для відправки метрик.
У великих проєктах, з великою кількістю користувачів, необхідно ретельно спостерігати всі процеси, що відбуваються в ньому.
Інформація про процеси може бути представлена різними чисельними показниками, наприклад: кількість запитів до вашого додатку,
час відповіді вашого сервісу на кожен запит, кількість користувачів на добу та інші. Ці різні чисельні показники ми називатимемо метриками.

Для збирання, зберігання та відображення подібних метрик існують готові рішення, наприклад Graphite, InfluxDB. Ми в рамках курсу
розробимо свою систему для збирання та зберігання метрик, засновану на клієнт-серверній архітектурі.

На цьому тижні ми почнемо з розробки клієнта для відправлення та отримання метрик. Наступного тижня, як фінальне завдання, вам буде
запропоновано реалізувати сервер для зберігання метрик.

Протокол взаємодії

Перш, ніж приступити до опису завдання, розглянемо протокол взаємодії, яким відбуватиметься обмін даними між клієнтом і сервером.

Клієнт та сервер взаємодіють між собою за простим текстовим протоколом через TCP сокети. Текстовий протокол має головну перевагу –
наочність, можна переглядати діалог взаємодії клієнтської та серверної сторони без використання додаткових інструментів.

Загальний формат запитів та відповідей.

Протокол підтримує два види запитів до сервера клієнта:
- надсилання даних для збереження їх на сервері
- отримання збережених даних

Загальний формат запиту клієнта:

<команда> <дані запиту><\n>

де:
- <команда> - команда сервера (команда може набувати одне з двох значень: put - зберегти дані на сервері, get - повернути
збережені дані з сервера),
- <дані запиту> - дані запиту (їх формат ми докладно розберемо в прикладі нижче),
- <\n> - символ перенесення рядка.

Звернемо вашу увагу на пробіл між командою та даними запиту та його відсутністю між даними та символом переводу на новий рядок.

Загальний формат відповідей сервера:

<статус відповіді><\n><дані відповіді><\n\n>

де:
- <статус відповіді> - статус виконання команди, допустимі два варіанти: "ok" - команда успішно виконана на сервері і
"error" - виконання команди завершилося помилкою
- <дані відповіді> - не обов'язкове поле (формат відповіді та випадки її відсутності будуть розглянуті у прикладі нижче)
- <\n\n> - два символи перенесення рядка.

Зверніть увагу, що статус відповіді та дані відповіді розділені символом перекладу рядка <\n>.

Приклад взаємодії сервера та клієнта.

Для наочності розглянемо протокол взаємодії між клієнтом та сервером на конкретному прикладі. У прикладі ми будемо збирати дані
про роботу операційної системи: cpu (завантаження процесора), usage (споживання пам'яті), disk_usage (споживання місця на жорсткому
диску), network_usage (статистика мережевих інтерфейсів). Такі дані можуть знадобитися для контролю завантаження серверів та прогнозу
розширення парку заліза компанії - простіше кажучи для моніторингу.

Які дані ми зберігатимемо?

Для кожної метрики (<key>) ми зберігатимемо дані про її значення (<value>) і часу, коли проводився вимір (<timestamp>) . Оскільки,
в реальному житті серверів може бути кілька, необхідно розрізняти дані отримані від різних серверів (у нашому прикладі є два сервери
palm і eardrum). Домовимося про назву метрик, назву метрики <key> у прикладі ми визначатимемо їх за правилом:

<назва сервера>.<назва даних>

Приклади назв метрик: "palm.cpu", "eardrum.memory".

Таким чином, на сервері по кожному ключу буде збережено список даних конкретних вимірювань (пара: значення, час вимірювання).

Звернемо вашу увагу, на те, що назви метрик можуть бути довільними і відрізнятися від тих, що використовуються в даному прикладі
(назва метрики не обов'язково повинна бути складовою і мати крапку в назві).

Запит клієнта.

Розглянемо приклад відправки на сервер даних для збереження. Нехай у нас є дані вимірювань - завантаження процесора «cpu» на сервері
"palm" під час 1150864247 дорівнювало 23.7 відсотка. Рядок запиту в цьому випадку матиме вигляд:

put palm.cpu 23.7 1150864247\n

У запиті на збереження ми можемо передати дані лише про один вимір.

Щоб отримати з сервера дані, збережені за ключем palm.cpu, необхідно в даних запиту просто передати ім'я ключа:

get palm.cpu\n

Для випадку, коли необхідно отримати всі дані, що зберігаються на сервері, як ключ використовується символ зірочки «*». Приклад
рядка запиту:

get *\n

Відповіді сервера.

Припустимо, що на сервері зберігаються дані:

key           | value | timestamp
-----------------------------------

"palm.cpu"    | 2.0   | 1150864247

"palm.cpu"    | 0,5   | 1150864248

"eardrum.cpu" | 3.0   | 1150864250

Тоді у відповідь на запит про отримання даних за ключем "palm.cpu" сервер надішле рядок:

ok\npalm.cpu 2.0 1150864247\npalm.cpu 0.5 1150864248\n\n

Дані відповіді містять дані про кожен збережений запис із ключем "palm.cpu" (метрика, значеня, часова мітка розділені пробілом),
які розділені символом переводу рядка \n.

Рядок відповіді сервера на запит про отримання всіх даних, що зберігаються на сервері (в якості ключа передано «*») у нашому
випадку буде таким:

ok\npalm.cpu 2.0 1150864247\npalm.cpu 0.5 1150864248\neardrum.cpu 3.0 1150864250\n\n

У випадках:
- коли у запиті на отримання даних передано не існуючий ключ
- успішного виконання команди збереження даних put
сервер надсилає клієнту рядок зі статусом «оk» та порожнім полем з даними відповіді:

ok\n\n

Якщо у параметрі запиту передані не валідні дані (наприклад: порушений формат запиту, помилкова команда або значення value і
timestamp не можуть бути приведені до необхідного типу даних) сервер надсилає рядок зі статусом відповіді error і даними відповіді
 wrong command:

error\nwrong command\n\n

Реалізація клієнта.

Необхідно реалізувати клас Client, в якому буде інкапсульовано з'єднання з сервером, клієнтський сокет та методи для отримання (get)
та відправлення (put) метрик на сервер. Відправлення та отримання даних у методах get і put має бути реалізовано відповідно до протоколу,
описаного вище. У конструктор класу Client повинна передаватися адресна пара хост і порт, а також необов'язковий аргумент timeout
(що має значення за замовчуванням - None). З'єднання з сервером встановлюється під час створення екземпляра класу Client і має
розриватися між запитами.

Приклад створення об'єкта клієнта та надсилання запитів на сервер:

>>> from solution import Client

>>> client = Client("127.0.0.1", 8888, timeout=15)

>>> client.put("palm.cpu", 0.5, timestamp=1150864247)

>>> client.put("palm.cpu", 2.0, timestamp=1150864248)

>>> client.put("palm.cpu", 0.5, timestamp=1150864248)


Метод put.

Метод put приймає як параметри: назву метрики, чисельне значення і необов'язковий іменований параметр timestamp. Якщо користувач
викликав метод put без аргументу timestamp, клієнт автоматично повинен підставити значення часової відмітки, отримаої за допомогою
виклику int(time.time()).

Метод put не повертає нічого у разі успішної відправки і викидає виняток користувача ClientError у разі не успішної.

Метод get.

Метод get приймає як параметр ім'я метрики, значення якої хочемо отримати. В якості імені метрики можна використовувати символ *,
про який ми згадували в описі протоколу.

Метод get повертає словник з метриками (дивіться приклад нижче) у разі успішного отримання відповіді від сервера та викидає виняток
ClientError у разі не успішного.

Клієнт отримує дані від сервера у текстовому вигляді, метод get повинен обробити рядок відповіді та повернути словник із отриманими
ключами із сервера. Значенням ключів у словнику є список кортежів:

[(timestamp1, metric_value1), (timestamp2, metric_value2), …]

Значення timestamp та metric_value мають бути перетворені відповідно до типів int та float. Список має бути відсортований за значенням
timestamp (за зростанням).

Приклад значення, що повертається при успішному виклику client.get("palm.cpu"):

{
   'palm.cpu': [
     (1150864247, 0.5),
     (1150864248, 0.5)
   ]
}

Зверніть увагу, що сервер зберігає дані з максимальною роздільною здатністю за одну секунду (Обратите внимание, что сервер хранит
данные с максимальным разрешением в одну секунду). Це означає, що якщо в ту саму секунду відправити дві однакові метрики, то буде
збережено лише одне значення, яке було оброблено останнім. Всі інші значення буде перезаписано. З цієї причини запит на ключ "palm.cpu"
повернув дані двох вимірювань.

Приклад значення, що повертається при успішному виклику client.get("*"):

{
  'palm.cpu': [
    (1150864247, 0.5),
    (1150864248, 0.5)
  ],
  'eardrum.cpu': [
    (1150864250, 3.0),
    (1150864251, 4.0)
  ],
  'eardrum.memory': [
    (1503320872, 4200000.0)
  ]
}

Якщо у відповідь на get-запит сервер повернув позитивну відповідь "ok\n\n", але без даних (тобто даних по ключу, що запитується немає),
то метод get клієнта повинен повернути порожній словник.

Отже, в якості рішення вам необхідно представити модуль з реалізованим у ньому класом Client, винятком користувача ClientError.
У класі Client повинні бути доступні методи get і put із описаною вище сигнатурою. При виклику методів get і put клієнт повинен
надсилати повідомлення в TCP-з'єднання з сервером (відповідно до описаного текстового протоколу), отримувати відповідь від сервера
та повертати словник з даними, у форматі описаному вище.

Примітка.

Незважаючи на те, що цього тижня ви вивчали асинхронність, клієнт має бути синхронним. Не турбуйтеся, якщо ви хотіли спробувати свої
сили в написанні асинхронного коду, наступного тижня у вас буде така можливість.

Успіхів під час виконання завдання!