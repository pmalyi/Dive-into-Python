Сервер для прийому метрик

На попередньому тижні ви розробили клієнтську мережну програму — клієнта для сервера метрик, який вміє відправляти та отримувати
дані про різні чисельні показники. Настав час фінального завдання - у ньому необхідно реалізувати серверну частину.

Як завжди, вам необхідно розробити програму в одному файлі-модулі, який ви завантажите на перевірку звичайним способом. Сервер повинен
відповідати протоколу, який був описаний у завданні до попереднього тижня. Він повинен вміти приймати від клієнтів команди put і get,
розбирати їх і формувати відповідь згідно з протоколом. За запитом put потрібно зберігати метрики у структурах даних у пам'яті процесу.
За запитом get сервер повинен віддавати дані у правильній послідовності. Під час роботи з клієнтом сервер повинен підтримувати сесії,
з'єднання з клієнтом між запитами не повинно "розриватися".

На верхньому рівні вашого модуля має бути оголошено функцію run_server(host, port) — вона приймає адресу та порт, на яких має бути
запущений сервер.

Для перевірки правильності рішення ми скористаємося своєю реалізацією клієнта і відправлятимемо на ваш сервер put і get запити, очікуючи
у відповідь правильні дані від сервера (відповідно до оголошеного протоколу). Усі запити будуть виконуватися з таймаутом - сервер повинен
відповідати за прийнятний час.

Сервер повинен бути готовим до неправильних команд з боку клієнта та віддавати клієнтові помилку у форматі, визначеному в протоколі.
У цих випадках робота сервера не повинна завершуватись аварійно.

На останньому тижні ми з вами розбирали приклад tcp-сервера на asyncio:

import asyncio


class ClientServerProtocol(asyncio.Protocol):
    def connection_made(self, transport):
        self.transport = transport

    def data_received(self, data):
        resp = process_data(data.decode())
        self.transport.write(resp.encode())


loop = asyncio.get_event_loop()
coro = loop.create_server(
    ClientServerProtocol,
    '127.0.0.1', 8181
)

server = loop.run_until_complete(coro)

try:
    loop.run_forever()
except KeyboardInterrupt:
    pass

server.close()
loop.run_until_complete(server.wait_closed())
loop.close()

Цей код створює tcp-з'єднання для адреси 127.0.0.1:8181 і слухає всі запити. При підключенні клієнта буде створено новий екземпляр класу
ClientServerProtocol, а при надходженні нових даних викличеться метод цього об'єкта - data_received. Всередині asyncio.Protocol захована
вся магія обробки запитів через корутини, залишається реалізувати протокол взаємодії між клієнтом та сервером.

Ви можете використовувати цей код як основу під час написання вашої реалізації сервера. Це не обов'язкова вимога. Для реалізації завдання
можна використовувати будь-які виклики зі стандартної бібліотеки Python 3 (звернемо вашу увагу, що в грейдері встановлена версія
Python 3.6). Сервер повинен вміти опрацьовувати запити від кількох клієнтів одночасно.

У процесі розробки сервера для тестування працездатності можна використовувати клієнт, написаний попереднього тижня.

Давайте ще раз подивимося на текстовий протокол у дії під час використання утиліти telnet:

$: telnet 127.0.0.1 8888
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
> get test_key
< ok
<
> got test_key
< error
< wrong command
<
> put test_key 12.0 1503319740
< ok
<
> put test_key 13.0 1503319739
< ok
<
> get test_key
< ok
< test_key 13.0 1503319739
< test_key 12.0 1503319740
<
> put another_key 10 1503319739
< ok
<
> get *
< ok
< test_key 13.0 1503319739
< test_key 12.0 1503319740
< another_key 10.0 1503319739
<

Також ви можете скористатися допоміжним скриптом, який використовує "еталонну" реалізацію клієнта, що відкривається після здачі
завдання на п'ятому тижні, для локального тестування написаного вами сервера:

"""
Це допоміжний скрипт для тестування сервера із завдання на 6 тижні.

Щоб запустити скрипт на локальному комп'ютері, розмістіть поруч файл client.py,
де міститься код клієнта, який відкривається після проходження завдання
Тижня 5.

Спочатку запускаєте ваш сервер на адресу 127.0.0.1 та порт 8888, а потім
запускаєте цей скрипт.
"""

import sys
from client import Client, ClientError


def run(host, port):
    client1 = Client(host, port, timeout=5)
    client2 = Client(host, port, timeout=5)
    command = "wrong command test\n"

    try:
        data = client1.get(command)
    except ClientError:
        pass
    except BaseException as err:
        print(f"Ошибка соединения с сервером: {err.__class__}: {err}")
        sys.exit(1)
    else:
        print("Неверная команда, отправленная серверу, должна возвращать ошибку протокола")
        sys.exit(1)

    command = 'some_key'
    try:
        data_1 = client1.get(command)
        data_2 = client1.get(command)
    except ClientError:
        print('Сервер вернул ответ на валидный запрос, который клиент определил, '
              'как не корректный.. ')
    except BaseException as err:
        print(f"Сервер должен поддерживать соединение с клиентом между запросами, "
              f"повторный запрос к серверу завершился ошибкой: {err.__class__}: {err}")
        sys.exit(1)

    assert data_1 == data_2 == {}, \
        "На запрос клиента на получения данных по не существующему ключу, сервер " \
        "вдолжен озвращать ответ с пустым полем данных."

    try:
        data_1 = client1.get(command)
        data_2 = client2.get(command)
    except ClientError:
        print('Сервер вернул ответ на валидный запрос, который клиент определил'
              ', как не корректный.. ')
    except BaseException as err:
        print(f"Сервер должен поддерживать соединение с несколькими клиентами: "
              f"{err.__class__}: {err}")
        sys.exit(1)

    assert data_1 == data_2 == {}, \
        "На запрос клиента на получения данных по не существующему ключу, сервер " \
        "должен возвращать ответ с пустым полем данных."

    try:
        client1.put("k1", 0.25, timestamp=1)
        client2.put("k1", 2.156, timestamp=2)
        client1.put("k1", 0.35, timestamp=3)
        client2.put("k2", 30, timestamp=4)
        client1.put("k2", 40, timestamp=5)
        client1.put("k2", 41, timestamp=5)
    except Exception as err:
        print(f"Ошибка вызова client.put(...) {err.__class__}: {err}")
        sys.exit(1)

    expected_metrics = {
        "k1": [(1, 0.25), (2, 2.156), (3, 0.35)],
        "k2": [(4, 30.0), (5, 41.0)],
    }

    try:
        metrics = client1.get("*")
        if metrics != expected_metrics:
            print(f"client.get('*') вернул неверный результат. Ожидается: "
                  f"{expected_metrics}. Получено: {metrics}")
            sys.exit(1)
    except Exception as err:
        print(f"Ошибка вызова client.get('*') {err.__class__}: {err}")
        sys.exit(1)

    expected_metrics = {"k2": [(4, 30.0), (5, 41.0)]}

    try:
        metrics = client2.get("k2")
        if metrics != expected_metrics:
            print(f"client.get('k2') вернул неверный результат. Ожидается: "
                  f"{expected_metrics}. Получено: {metrics}")
            sys.exit(1)
    except Exception as err:
        print(f"Ошибка вызова client.get('k2') {err.__class__}: {err}")
        sys.exit(1)

    try:
        result = client1.get("k3")
        if result != {}:
            print(
                f"Ошибка вызова метода get с ключом, который еще не был добавлен. "
                f"Ожидается: пустой словарь. Получено: {result}")
            sys.exit(1)
    except Exception as err:
        print(f"Ошибка вызова метода get с ключом, который еще не был добавлен: "
              f"{err.__class__} {err}")
        sys.exit(1)

    print("Похоже, что все верно! Попробуйте отправить решение на проверку.")


if __name__ == "__main__":
    run("127.0.0.1", 8888)


Успіхів у розробці!
